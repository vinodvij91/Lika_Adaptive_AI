#!/usr/bin/env python3
"""
Materials Science Discovery Pipeline - Production Version
With Materials Project API, Advanced Workflows, and DFT Integration
"""

import pandas as pd
import numpy as np
from typing import List, Dict, Optional, Tuple, Union
import json
import os
from dataclasses import dataclass
from datetime import datetime
import pickle
import subprocess
import tempfile
from pathlib import Path

# Materials Project API
try:
    from mp_api.client import MPRester
    MP_AVAILABLE = True
    print("✓ Materials Project API available")
except ImportError:
    MP_AVAILABLE = False
    print("○ Materials Project API not available - install with: pip install mp-api")

# Core scientific libraries
try:
    from pymatgen.core import Structure, Composition, Lattice, Element
    from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
    from pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter
    from pymatgen.io.cif import CifWriter
    from pymatgen.io.vasp import Poscar, Incar, Kpoints, Potcar
    from pymatgen.electronic_structure.bandstructure import BandStructureSymmLine
    PYMATGEN_AVAILABLE = True
    print("✓ Pymatgen available for materials structure analysis")
except ImportError:
    PYMATGEN_AVAILABLE = False
    print("○ Pymatgen not available - install with: pip install pymatgen")

# Machine Learning
try:
    import torch
    import torch.nn as nn
    from torch.utils.data import DataLoader, TensorDataset
    from torch.cuda.amp import autocast, GradScaler
    PYTORCH_AVAILABLE = True
    DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f"✓ PyTorch available - Device: {DEVICE}")
except ImportError:
    PYTORCH_AVAILABLE = False
    print("○ PyTorch not available")

# Distributed computing
try:
    import dask
    import dask.dataframe as dd
    from dask.distributed import Client, LocalCluster
    DASK_AVAILABLE = True
    print("✓ Dask available for distributed computing")
except ImportError:
    DASK_AVAILABLE = False
    print("○ Dask not available")

# Atomistic simulations
try:
    from ase import Atoms
    from ase.calculators.vasp import Vasp
    from ase.optimize import BFGS, LBFGS
    from ase.io import read, write
    from ase.calculators.espresso import Espresso
    ASE_AVAILABLE = True
    print("✓ ASE available for atomistic simulations")
except ImportError:
    ASE_AVAILABLE = False
    print("○ ASE not available - install with: pip install ase")

import multiprocessing as mp
from joblib import Parallel, delayed


# ============================================================================
# MATERIALS PROJECT DATA LOADER
# ============================================================================

class MaterialsProjectLoader:
    """
    Load training data from Materials Project database
    Access 150,000+ calculated materials properties
    """
    
    def __init__(self, api_key: str = None):
        """
        Initialize Materials Project client
        
        Args:
            api_key: Get your API key from https://materialsproject.org/api
        """
        self.api_key = api_key or os.getenv('MP_API_KEY')
        
        if not self.api_key:
            print("Warning: No Materials Project API key provided")
            print("Set MP_API_KEY environment variable or pass api_key parameter")
            print("Get key from: https://materialsproject.org/api")
            self.client = None
        elif MP_AVAILABLE:
            self.client = MPRester(self.api_key)
            print("✓ Connected to Materials Project")
        else:
            self.client = None
            print("○ Materials Project API not available")
    
    def load_training_data(self, 
                          property_name: str,
                          n_materials: int = 10000,
                          elements: List[str] = None,
                          additional_criteria: Dict = None) -> Tuple[List, np.ndarray]:
        """
        Load materials and property values for training
        
        Args:
            property_name: Property to load (e.g., 'band_gap', 'formation_energy_per_atom')
            n_materials: Maximum number of materials
            elements: Filter by elements (e.g., ['Li', 'Fe', 'O'])
            additional_criteria: Additional search criteria
        
        Returns:
            (materials_list, property_values)
        """
        if not self.client:
            print("Error: Materials Project client not initialized")
            return [], np.array([])
        
        print(f"\nLoading {property_name} data from Materials Project...")
        
        # Build query
        criteria = additional_criteria or {}
        if elements:
            criteria['elements'] = elements
        
        # Query Materials Project
        try:
            docs = self.client.summary.search(
                **criteria,
                fields=['material_id', 'formula_pretty', 'structure', property_name],
                num_chunks=10,
                chunk_size=1000
            )
            
            materials = []
            property_values = []
            
            for doc in docs[:n_materials]:
                # Extract data
                mat_id = doc.material_id
                composition = doc.formula_pretty
                structure = doc.structure
                prop_value = getattr(doc, property_name, None)
                
                if prop_value is not None:
                    material = Material(
                        composition=composition,
                        structure=structure,
                        material_id=str(mat_id),
                        source='Materials Project'
                    )
                    
                    materials.append(material)
                    property_values.append(prop_value)
            
            print(f"✓ Loaded {len(materials)} materials with {property_name} data")
            
            return materials, np.array(property_values)
            
        except Exception as e:
            print(f"Error loading from Materials Project: {e}")
            return [], np.array([])
    
    def load_battery_data(self, n_materials: int = 5000) -> Dict:
        """Load battery-specific data (cathodes, anodes)"""
        print("\nLoading battery materials from Materials Project...")
        
        # Get insertion electrodes
        try:
            battery_docs = self.client.insertion_electrodes.search(
                working_ion='Li',
                fields=['material_id', 'formula_pretty', 'average_voltage', 
                       'max_voltage', 'capacity_grav', 'energy_grav'],
                num_chunks=5
            )
            
            materials = []
            for doc in battery_docs[:n_materials]:
                materials.append({
                    'material_id': str(doc.material_id),
                    'composition': doc.formula_pretty,
                    'voltage': doc.average_voltage,
                    'capacity': doc.capacity_grav,
                    'energy_density': doc.energy_grav
                })
            
            print(f"✓ Loaded {len(materials)} battery materials")
            return {'cathodes': materials}
            
        except Exception as e:
            print(f"Error loading battery data: {e}")
            return {}
    
    def load_by_application(self, application: str, n_materials: int = 5000) -> List:
        """
        Load materials for specific applications
        
        Args:
            application: 'battery', 'solar', 'thermoelectric', 'catalyst', 'superconductor'
        """
        if application == 'battery':
            return self.load_battery_data(n_materials)
        
        elif application == 'solar':
            # Load materials with suitable band gaps (1.0-1.8 eV)
            materials, band_gaps = self.load_training_data(
                'band_gap',
                n_materials=n_materials,
                additional_criteria={'band_gap': (1.0, 1.8)}
            )
            return materials
        
        elif application == 'thermoelectric':
            # Load materials with band gaps 0.1-0.6 eV
            materials, _ = self.load_training_data(
                'band_gap',
                n_materials=n_materials,
                additional_criteria={'band_gap': (0.1, 0.6)}
            )
            return materials
        
        elif application == 'superconductor':
            # Load materials with specific elements
            elements = ['Y', 'La', 'Ba', 'Cu', 'Fe', 'As', 'Nb', 'Ti']
            materials, _ = self.load_training_data(
                'formation_energy_per_atom',
                n_materials=n_materials,
                elements=elements
            )
            return materials
        
        else:
            print(f"Unknown application: {application}")
            return []
    
    def get_phase_diagram(self, elements: List[str]) -> Optional[PhaseDiagram]:
        """Get phase diagram for element system"""
        if not self.client:
            return None
        
        print(f"\nRetrieving phase diagram for {'-'.join(elements)}...")
        
        try:
            # Get all entries in system
            entries = self.client.get_entries_in_chemsys(elements)
            
            # Create phase diagram
            pd = PhaseDiagram(entries)
            
            print(f"✓ Phase diagram created with {len(entries)} phases")
            return pd
            
        except Exception as e:
            print(f"Error creating phase diagram: {e}")
            return None


# ============================================================================
# DFT CALCULATORS (VASP & Quantum ESPRESSO)
# ============================================================================

class VASPCalculator:
    """
    VASP (Vienna Ab initio Simulation Package) calculator
    Industry standard for materials DFT calculations
    """
    
    def __init__(self, 
                 vasp_cmd: str = 'vasp_std',
                 potcar_dir: str = None,
                 nprocs: int = 16):
        """
        Args:
            vasp_cmd: VASP executable ('vasp_std', 'vasp_gam', 'vasp_ncl')
            potcar_dir: Directory containing POTCAR files
            nprocs: Number of MPI processes
        """
        self.vasp_cmd = vasp_cmd
        self.potcar_dir = potcar_dir or os.getenv('VASP_PP_PATH')
        self.nprocs = nprocs
        
        if not self.potcar_dir:
            print("Warning: VASP POTCAR directory not set")
            print("Set VASP_PP_PATH environment variable")
    
    def setup_calculation(self, 
                         material: Material,
                         calc_type: str = 'relax') -> Dict:
        """
        Setup VASP calculation
        
        Args:
            material: Material to calculate
            calc_type: 'relax', 'static', 'band', 'dos'
        
        Returns:
            VASP input files configuration
        """
        if not material.structure or not PYMATGEN_AVAILABLE:
            return {}
        
        structure = material.structure
        
        # INCAR settings based on calculation type
        if calc_type == 'relax':
            incar = {
                'PREC': 'Accurate',
                'ENCUT': 520,
                'EDIFF': 1e-5,
                'IBRION': 2,  # CG relaxation
                'ISIF': 3,    # Relax cell + ions
                'NSW': 200,   # Max ionic steps
                'LWAVE': False,
                'LCHARG': False
            }
        
        elif calc_type == 'static':
            incar = {
                'PREC': 'Accurate',
                'ENCUT': 520,
                'EDIFF': 1e-6,
                'ISMEAR': -5,  # Tetrahedron method
                'LORBIT': 11,  # DOSCAR with local DOS
                'LWAVE': True,
                'LCHARG': True
            }
        
        elif calc_type == 'band':
            incar = {
                'PREC': 'Accurate',
                'ENCUT': 520,
                'EDIFF': 1e-6,
                'ISMEAR': 0,
                'SIGMA': 0.05,
                'ICHARG': 11,  # Read from CHGCAR
                'LWAVE': False,
                'LCHARG': False
            }
        
        elif calc_type == 'dos':
            incar = {
                'PREC': 'Accurate',
                'ENCUT': 520,
                'EDIFF': 1e-6,
                'ISMEAR': -5,
                'NEDOS': 2001,
                'LORBIT': 11
            }
        
        return {
            'structure': structure,
            'incar': incar,
            'calc_type': calc_type
        }
    
    def run_calculation(self, 
                       material: Material,
                       calc_type: str = 'relax',
                       workdir: str = None) -> Dict:
        """
        Run VASP calculation
        
        Args:
            material: Material to calculate
            calc_type: Calculation type
            workdir: Working directory (creates temp if None)
        
        Returns:
            Results dictionary
        """
        if not ASE_AVAILABLE:
            return {'error': 'ASE not available'}
        
        # Create working directory
        if workdir is None:
            workdir = tempfile.mkdtemp(prefix='vasp_')
        os.makedirs(workdir, exist_ok=True)
        
        print(f"\n[VASP] Running {calc_type} calculation for {material.composition}")
        print(f"  Working directory: {workdir}")
        
        # Setup calculation
        config = self.setup_calculation(material, calc_type)
        if not config:
            return {'error': 'Failed to setup calculation'}
        
        # Convert Pymatgen Structure to ASE Atoms
        structure = config['structure']
        atoms = self._structure_to_atoms(structure)
        
        # Setup VASP calculator
        calc = Vasp(
            directory=workdir,
            command=f'mpirun -np {self.nprocs} {self.vasp_cmd}',
            **config['incar']
        )
        
        atoms.calc = calc
        
        try:
            # Run calculation
            if calc_type == 'relax':
                opt = LBFGS(atoms, trajectory=f'{workdir}/relax.traj')
                opt.run(fmax=0.01)
            
            # Get results
            energy = atoms.get_potential_energy()
            forces = atoms.get_forces()
            
            results = {
                'status': 'completed',
                'energy': energy,
                'energy_per_atom': energy / len(atoms),
                'forces': forces,
                'final_structure': atoms,
                'workdir': workdir
            }
            
            # Get band gap if available
            if calc_type in ['static', 'band', 'dos']:
                results['band_gap'] = self._extract_band_gap(workdir)
            
            print(f"✓ VASP calculation completed")
            print(f"  Energy: {energy:.4f} eV")
            
            return results
            
        except Exception as e:
            print(f"Error running VASP: {e}")
            return {'error': str(e), 'workdir': workdir}
    
    def _structure_to_atoms(self, structure: Structure) -> Atoms:
        """Convert Pymatgen Structure to ASE Atoms"""
        atoms = Atoms(
            symbols=[str(site.specie) for site in structure],
            positions=structure.cart_coords,
            cell=structure.lattice.matrix,
            pbc=True
        )
        return atoms
    
    def _extract_band_gap(self, workdir: str) -> Optional[float]:
        """Extract band gap from VASP output"""
        try:
            from pymatgen.io.vasp.outputs import Vasprun
            vasprun = Vasprun(f"{workdir}/vasprun.xml")
            band_gap = vasprun.get_band_structure().get_band_gap()['energy']
            return band_gap
        except:
            return None


class QuantumESPRESSOCalculator:
    """
    Quantum ESPRESSO calculator
    Open-source DFT code, alternative to VASP
    """
    
    def __init__(self, 
                 pw_cmd: str = 'pw.x',
                 pseudo_dir: str = None,
                 nprocs: int = 16):
        """
        Args:
            pw_cmd: Quantum ESPRESSO pw.x executable
            pseudo_dir: Directory containing pseudopotentials
            nprocs: Number of MPI processes
        """
        self.pw_cmd = pw_cmd
        self.pseudo_dir = pseudo_dir or os.getenv('ESPRESSO_PSEUDO')
        self.nprocs = nprocs
        
        if not self.pseudo_dir:
            print("Warning: Quantum ESPRESSO pseudopotential directory not set")
            print("Set ESPRESSO_PSEUDO environment variable")
    
    def run_calculation(self,
                       material: Material,
                       calc_type: str = 'scf',
                       workdir: str = None) -> Dict:
        """
        Run Quantum ESPRESSO calculation
        
        Args:
            material: Material to calculate
            calc_type: 'scf', 'relax', 'vc-relax', 'bands', 'nscf'
        
        Returns:
            Results dictionary
        """
        if not ASE_AVAILABLE:
            return {'error': 'ASE not available'}
        
        if workdir is None:
            workdir = tempfile.mkdtemp(prefix='qe_')
        os.makedirs(workdir, exist_ok=True)
        
        print(f"\n[QE] Running {calc_type} calculation for {material.composition}")
        
        # Convert structure
        structure = material.structure
        atoms = self._structure_to_atoms(structure)
        
        # Setup calculator
        input_data = {
            'control': {
                'calculation': calc_type,
                'pseudo_dir': self.pseudo_dir,
                'outdir': workdir,
                'prefix': material.material_id or 'pwscf'
            },
            'system': {
                'ecutwfc': 60,  # Ry
                'ecutrho': 480,
                'occupations': 'smearing',
                'smearing': 'gaussian',
                'degauss': 0.02
            },
            'electrons': {
                'conv_thr': 1e-8,
                'mixing_beta': 0.7
            }
        }
        
        if calc_type in ['relax', 'vc-relax']:
            input_data['ions'] = {
                'ion_dynamics': 'bfgs'
            }
        
        if calc_type == 'vc-relax':
            input_data['cell'] = {
                'cell_dynamics': 'bfgs'
            }
        
        calc = Espresso(
            command=f'mpirun -np {self.nprocs} {self.pw_cmd} -in PREFIX.pwi > PREFIX.pwo',
            input_data=input_data,
            pseudopotentials=self._get_pseudopotentials(atoms),
            kpts=(4, 4, 4)
        )
        
        atoms.calc = calc
        
        try:
            energy = atoms.get_potential_energy()
            forces = atoms.get_forces()
            
            results = {
                'status': 'completed',
                'energy': energy,
                'forces': forces,
                'final_structure': atoms,
                'workdir': workdir
            }
            
            print(f"✓ QE calculation completed")
            print(f"  Energy: {energy:.4f} eV")
            
            return results
            
        except Exception as e:
            print(f"Error running Quantum ESPRESSO: {e}")
            return {'error': str(e)}
    
    def _structure_to_atoms(self, structure: Structure) -> Atoms:
        """Convert Pymatgen Structure to ASE Atoms"""
        atoms = Atoms(
            symbols=[str(site.specie) for site in structure],
            positions=structure.cart_coords,
            cell=structure.lattice.matrix,
            pbc=True
        )
        return atoms
    
    def _get_pseudopotentials(self, atoms: Atoms) -> Dict:
        """Get pseudopotential files for each element"""
        # Simplified - in production, map elements to specific PP files
        pseudos = {}
        for symbol in set(atoms.get_chemical_symbols()):
            pseudos[symbol] = f"{symbol}.UPF"
        return pseudos


# ============================================================================
# SPECIALIZED WORKFLOWS
# ============================================================================

class SuperconductorDiscovery(MaterialsDiscoveryPipeline):
    """
    Discover novel superconducting materials
    Focus on high-Tc superconductors
    """
    
    def __init__(self, use_gpu: bool = True, n_workers: int = None, mp_api_key: str = None):
        super().__init__(use_gpu, n_workers)
        self.mp_loader = MaterialsProjectLoader(mp_api_key)
        self.vasp_calc = VASPCalculator()
    
    def discover_high_tc_materials(self, 
                                  target_tc: float = 77,  # Liquid N2 temperature
                                  n_candidates: int = 5000) -> pd.DataFrame:
        """
        Discover high-Tc superconductor candidates
        
        Strategy:
        1. Generate compositions with known SC elements
        2. Predict electronic structure (metallic, small gap)
        3. Check for favorable phonon properties
        4. DFT validation of top candidates
        """
        print("\n" + "="*70)
        print("SUPERCONDUCTOR DISCOVERY WORKFLOW")
        print("="*70)
        print(f"Target Tc: {target_tc} K (liquid nitrogen temperature)")
        
        # Step 1: Generate candidates with SC-favorable elements
        print("\n[1/5] Generating candidates...")
        sc_elements = [
            # Cuprates
            'Y', 'La', 'Ba', 'Sr', 'Ca', 'Cu', 'O',
            # Iron-based
            'Fe', 'As', 'Se', 'Te', 'P',
            # MgB2-type
            'Mg', 'B', 'Al', 'C',
            # A15/Chevrel
            'Nb', 'V', 'Ti', 'Mo', 'Pb', 'S'
        ]
        
        compositions = self.generator.generate_compositions(
            target_properties={'band_gap': 0.0},  # Metallic
            n_candidates=n_candidates,
            elements=sc_elements
        )
        
        materials = [Material(composition=comp, material_id=f"SC_{i:06d}",
                            tags=['superconductor_candidate'])
                    for i, comp in enumerate(compositions)]
        
        # Step 2: Load training data from Materials Project
        print("\n[2/5] Loading SC training data from Materials Project...")
        training_materials = self.mp_loader.load_by_application('superconductor', n_materials=2000)
        
        # Step 3: Predict electronic properties
        print("\n[3/5] Predicting electronic properties...")
        predictions = self.property_predictor.batch_predict(materials)
        
        # Step 4: Filter for metallic or small-gap semiconductors
        print("\n[4/5] Filtering for SC-favorable properties...")
        candidates = []
        for mat, pred in zip(materials, predictions):
            # Criteria for SC screening
            if pred.band_gap is not None and pred.band_gap < 0.1:  # Metallic or very small gap
                if pred.formation_energy is not None and pred.formation_energy < 0:  # Stable
                    candidates.append((mat, pred))
        
        print(f"  Filtered to {len(candidates)} promising candidates")
        
        # Step 5: DFT validation of top 20
        print("\n[5/5] DFT validation of top candidates...")
        top_candidates = candidates[:20]
        
        dft_results = []
        for mat, pred in top_candidates:
            result = self.vasp_calc.run_calculation(mat, calc_type='static')
            if result.get('status') == 'completed':
                dft_results.append({
                    'material_id': mat.material_id,
                    'composition': mat.composition,
                    'predicted_band_gap': pred.band_gap,
                    'dft_energy': result['energy_per_atom'],
                    'dft_band_gap': result.get('band_gap'),
                    'sc_score': self._calculate_sc_score(mat, pred, result)
                })
        
        df = pd.DataFrame(dft_results)
        df = df.sort_values('sc_score', ascending=False)
        
        print(f"\n✓ Superconductor discovery complete!")
        print(f"  Top candidates:")
        print(df.head(10))
        
        return df
    
    def _calculate_sc_score(self, material, prediction, dft_result) -> float:
        """Calculate superconductor promise score"""
        score = 0.5
        
        # Metallic behavior
        if dft_result.get('dft_band_gap') is not None:
            if dft_result['dft_band_gap'] < 0.05:
                score += 0.3
        
        # Stability
        if dft_result.get('dft_energy') is not None:
            if dft_result['dft_energy'] < -2.0:
                score += 0.2
        
        return score


class CatalystDiscovery(MaterialsDiscoveryPipeline):
    """
    Discover novel catalytic materials
    Focus on hydrogen evolution, oxygen reduction, CO2 reduction
    """
    
    def __init__(self, use_gpu: bool = True, n_workers: int = None, mp_api_key: str = None):
        super().__init__(use_gpu, n_workers)
        self.mp_loader = MaterialsProjectLoader(mp_api_key)
    
    def discover_her_catalysts(self, n_candidates: int = 5000) -> pd.DataFrame:
        """
        Discover Hydrogen Evolution Reaction (HER) catalysts
        
        Target: Materials with d-band center near Fermi level
        """
        print("\n" + "="*70)
        print("HER CATALYST DISCOVERY")
        print("="*70)
        
        # Transition metals and combinations
        her_elements = ['Pt', 'Pd', 'Ni', 'Co', 'Fe', 'Mo', 'W', 'S', 'Se', 'N', 'C']
        
        compositions = self.generator.generate_compositions(
            target_properties={'work_function': 5.0},  # Optimal for HER
            n_candidates=n_candidates,
            elements=her_elements
        )
        
        materials = [Material(composition=comp, material_id=f"HER_{i:06d}",
                            tags=['HER_catalyst'])
                    for i, comp in enumerate(compositions)]
        
        # Predict properties
        predictions = self.property_predictor.batch_predict(materials)
        
        # Rank by HER activity descriptors
        results = []
        for mat, pred in zip(materials, predictions):
            her_score = self._calculate_her_score(pred)
            results.append({
                'material_id': mat.material_id,
                'composition': mat.composition,
                'work_function': pred.work_function,
                'her_score': her_score
            })
        
        df = pd.DataFrame(results)
        df = df.sort_values('her_score', ascending=False)
        
        print(f"\n✓ HER catalyst discovery complete")
        print(df.head(10))
        
        return df
    
    def discover_orr_catalysts(self, n_candidates: int = 5000) -> pd.DataFrame:
        """
        Discover Oxygen Reduction Reaction (ORR) catalysts
        For fuel cells and metal-air batteries
        """
        print("\n" + "="*70)
        print("ORR CATALYST DISCOVERY")
        print("="*70)
        
        orr_elements = ['Pt', 'Pd', 'Fe', 'Co', 'Ni', 'Mn', 'N', 'C', 'O']
        
        compositions = self.generator.generate_compositions(
            target_properties={},
            n_candidates=n_candidates,
            elements=orr_elements
        )
        
        materials = [Material(composition=comp, material_id=f"ORR_{i:06d}",
                            tags=['ORR_catalyst'])
                    for i, comp in enumerate(compositions)]
        
        predictions = self.property_predictor.batch_predict(materials)
        
        results = []
        for mat, pred in zip(materials, predictions):
            orr_score = self._calculate_orr_score(pred)
            results.append({
                'material_id': mat.material_id,
                'composition': mat.composition,
                'orr_score': orr_score
            })
        
        df = pd.DataFrame(results)
        df = df.sort_values('orr_score', ascending=False)
        
        print(f"\n✓ ORR catalyst discovery complete")
        return df
    
    def _calculate_her_score(self, prediction) -> float:
        """Calculate HER activity score"""
        score = 0.5
        if prediction.work_function:
            # Optimal work function ~4.5-5.5 eV
            if 4.5 <= prediction.work_function <= 5.5:
                score += 0.4
        return score
    
    def _calculate_orr_score(self, prediction) -> float:
        """Calculate ORR activity score"""
        # Placeholder - in production, use d-band center and oxygen binding energy
        return 0.7


class ThermoelectricDiscovery(MaterialsDiscoveryPipeline):
    """
    Discover novel thermoelectric materials
    High ZT = (S²σT)/κ where S=Seebeck, σ=conductivity, κ=thermal conductivity
    """
    
    def __init__(self, use_gpu: bool = True, n_workers: int = None, mp_api_key: str = None):
        super().__init__(use_gpu, n_workers)
        self.mp_loader = MaterialsProjectLoader(mp_api_key)
    
    def discover_high_zt_materials(self, 
                                  target_zt: float = 2.0,
                                  temperature: float = 300) -> pd.DataFrame:
        """
        Discover high-ZT thermoelectric materials
        
        Strategy:
        1. Band gap 0.1-0.6 eV (optimal for thermoelectrics)
        2. Heavy elements (low thermal conductivity)
        3. Complex crystal structure (phonon scattering)
        """
        print("\n" + "="*70)
        print("THERMOELECTRIC DISCOVERY")
        print("="*70)
        print(f"Target ZT > {target_zt} at {temperature}K")#!/usr/bin/env python3
"""
Materials Science Discovery Pipeline
Advanced AI-driven materials discovery with property prediction and synthesis planning
"""

import pandas as pd
import numpy as np
from typing import List, Dict, Optional, Tuple, Union
import json
import os
from dataclasses import dataclass
from datetime import datetime
import pickle

# Core scientific libraries
try:
    from pymatgen.core import Structure, Composition, Lattice
    from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
    from pymatgen.analysis.phase_diagram import PhaseDiagram, PDPlotter
    from pymatgen.io.cif import CifWriter
    PYMATGEN_AVAILABLE = True
    print("✓ Pymatgen available for materials structure analysis")
except ImportError:
    PYMATGEN_AVAILABLE = False
    print("○ Pymatgen not available - install with: pip install pymatgen")

# Machine Learning
try:
    import torch
    import torch.nn as nn
    from torch.utils.data import DataLoader, TensorDataset
    from torch.cuda.amp import autocast, GradScaler
    PYTORCH_AVAILABLE = True
    DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f"✓ PyTorch available - Device: {DEVICE}")
except ImportError:
    PYTORCH_AVAILABLE = False
    print("○ PyTorch not available")

# Distributed computing
try:
    import dask
    import dask.dataframe as dd
    from dask.distributed import Client, LocalCluster
    DASK_AVAILABLE = True
    print("✓ Dask available for distributed computing")
except ImportError:
    DASK_AVAILABLE = False
    print("○ Dask not available")

# Quantum computing (optional)
try:
    from qiskit import QuantumCircuit, Aer, execute
    from qiskit.algorithms import VQE
    QISKIT_AVAILABLE = True
    print("✓ Qiskit available for quantum simulations")
except ImportError:
    QISKIT_AVAILABLE = False
    print("○ Qiskit not available")

# DFT/Simulation tools
try:
    from ase import Atoms
    from ase.calculators.lj import LennardJones
    from ase.optimize import BFGS
    ASE_AVAILABLE = True
    print("✓ ASE available for atomistic simulations")
except ImportError:
    ASE_AVAILABLE = False
    print("○ ASE not available - install with: pip install ase")

import multiprocessing as mp
from joblib import Parallel, delayed


# ============================================================================
# DATA STRUCTURES
# ============================================================================

@dataclass
class Material:
    """Material composition and structure"""
    composition: str  # Chemical formula (e.g., "Fe2O3", "LiFePO4")
    structure: Optional[object] = None  # Pymatgen Structure
    space_group: Optional[str] = None
    crystal_system: Optional[str] = None
    lattice_params: Optional[Dict] = None
    cif_data: Optional[str] = None
    
    # Computed properties
    formation_energy: Optional[float] = None
    band_gap: Optional[float] = None
    density: Optional[float] = None
    
    # Descriptors for ML
    features: Optional[np.ndarray] = None
    
    # Metadata
    material_id: Optional[str] = None
    source: str = "Generated"
    tags: List[str] = None


@dataclass
class PropertyPrediction:
    """Predicted material properties"""
    material_id: str
    
    # Mechanical properties
    bulk_modulus: Optional[float] = None
    shear_modulus: Optional[float] = None
    youngs_modulus: Optional[float] = None
    poissons_ratio: Optional[float] = None
    hardness: Optional[float] = None
    
    # Electronic properties
    band_gap: Optional[float] = None
    work_function: Optional[float] = None
    conductivity: Optional[float] = None
    
    # Thermal properties
    melting_point: Optional[float] = None
    thermal_conductivity: Optional[float] = None
    specific_heat: Optional[float] = None
    
    # Magnetic properties
    magnetic_moment: Optional[float] = None
    curie_temperature: Optional[float] = None
    
    # Energy storage (batteries)
    voltage: Optional[float] = None
    capacity: Optional[float] = None
    ion_mobility: Optional[float] = None
    
    # Synthesis
    synthesizability_score: Optional[float] = None
    synthesis_temperature: Optional[float] = None
    
    # Stability
    formation_energy: Optional[float] = None
    energy_above_hull: Optional[float] = None
    decomposition_temperature: Optional[float] = None


@dataclass
class SimulationRun:
    """Atomistic simulation configuration"""
    material: Material
    simulation_type: str  # DFT, MD, Monte Carlo
    parameters: Dict
    results: Optional[Dict] = None
    status: str = "pending"
    compute_time: Optional[float] = None


# ============================================================================
# MATERIAL REPRESENTATION & FEATURIZATION
# ============================================================================

class MaterialFeaturizer:
    """
    Convert material compositions/structures to ML-ready features
    Uses compositional, structural, and physical descriptors
    """
    
    def __init__(self):
        self.element_properties = self._load_element_properties()
    
    def _load_element_properties(self) -> Dict:
        """Load periodic table properties"""
        # Simplified - in production, load from comprehensive database
        return {
            'atomic_number': {},
            'atomic_mass': {},
            'electronegativity': {},
            'ionization_energy': {},
            'electron_affinity': {},
            'atomic_radius': {},
            'valence_electrons': {}
        }
    
    def featurize_composition(self, composition: str) -> np.ndarray:
        """
        Generate compositional features from chemical formula
        
        Features include:
        - Stoichiometric descriptors
        - Weighted average of element properties
        - Element fractions
        - Max/min/range of element properties
        """
        if not PYMATGEN_AVAILABLE:
            return np.random.rand(100)  # Placeholder
        
        comp = Composition(composition)
        
        features = []
        
        # Number of elements
        features.append(len(comp.elements))
        
        # Weighted properties
        for prop_name in ['atomic_number', 'electronegativity', 'atomic_radius']:
            values = []
            weights = []
            for element, amount in comp.items():
                # Get property value (simplified)
                values.append(element.Z)  # Placeholder
                weights.append(amount)
            
            if values:
                weighted_avg = np.average(values, weights=weights)
                features.extend([
                    weighted_avg,
                    np.min(values),
                    np.max(values),
                    np.std(values)
                ])
        
        # Stoichiometry features
        amounts = list(comp.values())
        features.extend([
            np.mean(amounts),
            np.std(amounts),
            np.max(amounts),
            np.min(amounts)
        ])
        
        return np.array(features)
    
    def featurize_structure(self, structure: Structure) -> np.ndarray:
        """
        Generate structural features
        
        Features include:
        - Volume per atom
        - Packing fraction
        - Coordination numbers
        - Bond lengths/angles
        - Symmetry descriptors
        """
        if not PYMATGEN_AVAILABLE:
            return np.random.rand(50)  # Placeholder
        
        features = []
        
        # Volume descriptors
        features.append(structure.volume / len(structure))
        features.append(structure.density)
        
        # Symmetry
        sga = SpacegroupAnalyzer(structure)
        features.append(sga.get_space_group_number())
        
        # Lattice parameters
        a, b, c = structure.lattice.abc
        alpha, beta, gamma = structure.lattice.angles
        features.extend([a, b, c, alpha, beta, gamma])
        
        # Coordination environment
        # (Simplified - full implementation would use local environment analysis)
        features.extend([8.0, 6.0, 4.0])  # Avg coordination numbers
        
        return np.array(features)
    
    def featurize(self, material: Material) -> np.ndarray:
        """Complete featurization of material"""
        comp_features = self.featurize_composition(material.composition)
        
        if material.structure:
            struct_features = self.featurize_structure(material.structure)
            return np.concatenate([comp_features, struct_features])
        
        return comp_features


# ============================================================================
# PROPERTY PREDICTION MODELS
# ============================================================================

class PropertyPredictor(nn.Module):
    """
    Multi-task neural network for material property prediction
    GPU-accelerated with mixed precision training
    """
    
    def __init__(self, input_dim: int, property_dims: Dict[str, int]):
        super(PropertyPredictor, self).__init__()
        
        # Shared encoder
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 512),
            nn.BatchNorm1d(512),
            nn.ReLU(),
            nn.Dropout(0.2),
            
            nn.Linear(512, 256),
            nn.BatchNorm1d(256),
            nn.ReLU(),
            nn.Dropout(0.2),
            
            nn.Linear(256, 128),
            nn.BatchNorm1d(128),
            nn.ReLU()
        )
        
        # Property-specific heads
        self.property_heads = nn.ModuleDict()
        for prop_name, output_dim in property_dims.items():
            self.property_heads[prop_name] = nn.Sequential(
                nn.Linear(128, 64),
                nn.ReLU(),
                nn.Linear(64, output_dim)
            )
    
    def forward(self, x, property_name: str = None):
        """Forward pass for specific property or all properties"""
        encoded = self.encoder(x)
        
        if property_name:
            return self.property_heads[property_name](encoded)
        
        # Return all properties
        outputs = {}
        for prop_name, head in self.property_heads.items():
            outputs[prop_name] = head(encoded)
        
        return outputs


class PropertyPredictionEngine:
    """Engine for training and predicting material properties"""
    
    def __init__(self, use_gpu: bool = True, use_mixed_precision: bool = True):
        self.use_gpu = use_gpu and PYTORCH_AVAILABLE and torch.cuda.is_available()
        self.use_mixed_precision = use_mixed_precision and self.use_gpu
        self.device = DEVICE if self.use_gpu else torch.device('cpu')
        
        self.models = {}
        self.scalers = {}
        self.featurizer = MaterialFeaturizer()
    
    def train_property_model(self, 
                            materials: List[Material],
                            property_name: str,
                            property_values: np.ndarray,
                            epochs: int = 100):
        """
        Train model for specific property with mixed precision
        
        Args:
            materials: List of materials
            property_name: Property to predict (e.g., 'band_gap')
            property_values: Ground truth values
            epochs: Training epochs
        """
        print(f"\n[{'GPU' if self.use_gpu else 'CPU'}] Training {property_name} model...")
        
        # Featurize materials
        X = np.array([self.featurizer.featurize(m) for m in materials])
        y = property_values
        
        # Convert to tensors
        X_tensor = torch.FloatTensor(X).to(self.device)
        y_tensor = torch.FloatTensor(y).unsqueeze(1).to(self.device)
        
        # Create model
        model = PropertyPredictor(
            input_dim=X.shape[1],
            property_dims={property_name: 1}
        ).to(self.device)
        
        optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
        criterion = nn.MSELoss()
        
        # Mixed precision training
        scaler = GradScaler() if self.use_mixed_precision else None
        
        # Training loop
        dataset = TensorDataset(X_tensor, y_tensor)
        dataloader = DataLoader(dataset, batch_size=256, shuffle=True)
        
        for epoch in range(epochs):
            total_loss = 0
            model.train()
            
            for batch_X, batch_y in dataloader:
                optimizer.zero_grad()
                
                if self.use_mixed_precision:
                    with autocast():
                        outputs = model(batch_X, property_name)
                        loss = criterion(outputs, batch_y)
                    
                    scaler.scale(loss).backward()
                    scaler.step(optimizer)
                    scaler.update()
                else:
                    outputs = model(batch_X, property_name)
                    loss = criterion(outputs, batch_y)
                    loss.backward()
                    optimizer.step()
                
                total_loss += loss.item()
            
            if (epoch + 1) % 20 == 0:
                avg_loss = total_loss / len(dataloader)
                print(f"  Epoch {epoch+1}/{epochs}, Loss: {avg_loss:.6f}")
        
        self.models[property_name] = model
        print(f"✓ {property_name} model trained")
    
    def predict_properties(self, material: Material) -> PropertyPrediction:
        """Predict all properties for a material"""
        features = self.featurizer.featurize(material)
        X = torch.FloatTensor(features).unsqueeze(0).to(self.device)
        
        predictions = PropertyPrediction(material_id=material.material_id)
        
        # Predict each property
        for prop_name, model in self.models.items():
            model.eval()
            with torch.no_grad():
                if self.use_mixed_precision:
                    with autocast():
                        pred = model(X, prop_name)
                else:
                    pred = model(X, prop_name)
                
                value = pred.cpu().numpy()[0, 0]
                setattr(predictions, prop_name, float(value))
        
        return predictions
    
    def batch_predict(self, materials: List[Material]) -> List[PropertyPrediction]:
        """Batch prediction for multiple materials (GPU-optimized)"""
        print(f"\n[{'GPU' if self.use_gpu else 'CPU'}] Predicting properties for {len(materials)} materials...")
        
        # Featurize all materials
        X = np.array([self.featurizer.featurize(m) for m in materials])
        X_tensor = torch.FloatTensor(X).to(self.device)
        
        predictions = []
        
        # Batch predictions
        batch_size = 1000 if self.use_gpu else 100
        
        for i in range(0, len(materials), batch_size):
            batch_materials = materials[i:i+batch_size]
            batch_X = X_tensor[i:i+batch_size]
            
            for material in batch_materials:
                pred = PropertyPrediction(material_id=material.material_id)
                
                for prop_name, model in self.models.items():
                    model.eval()
                    with torch.no_grad():
                        if self.use_mixed_precision:
                            with autocast():
                                output = model(batch_X[:1], prop_name)
                        else:
                            output = model(batch_X[:1], prop_name)
                        
                        setattr(pred, prop_name, float(output.cpu().numpy()[0, 0]))
                
                predictions.append(pred)
            
            if (i + batch_size) % 5000 == 0:
                print(f"  Processed {i + batch_size}/{len(materials)} materials")
        
        print(f"✓ Batch prediction complete")
        return predictions


# ============================================================================
# MATERIALS GENERATION (INVERSE DESIGN)
# ============================================================================

class MaterialsGenerator:
    """
    Generate novel materials with desired properties
    Uses generative models (VAE, GAN, or transformer)
    """
    
    def __init__(self, use_gpu: bool = True):
        self.use_gpu = use_gpu and torch.cuda.is_available() if PYTORCH_AVAILABLE else False
        self.device = DEVICE if self.use_gpu else torch.device('cpu')
    
    def generate_compositions(self, 
                             target_properties: Dict[str, float],
                             n_candidates: int = 1000,
                             elements: List[str] = None) -> List[str]:
        """
        Generate candidate compositions with target properties
        
        Args:
            target_properties: Desired properties (e.g., {'band_gap': 2.0, 'formation_energy': -2.5})
            n_candidates: Number of candidates to generate
            elements: Allowed elements (if None, uses all stable elements)
        
        Returns:
            List of chemical formulas
        """
        print(f"\nGenerating {n_candidates} candidate materials...")
        print(f"Target properties: {target_properties}")
        
        # Simplified generation - in production, use VAE/GAN or compositional sampling
        candidates = []
        
        if elements is None:
            # Common elements for different applications
            elements = ['Li', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'K', 'Ca', 'Ti', 
                       'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge',
                       'As', 'Se', 'Zr', 'Nb', 'Mo', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd',
                       'In', 'Sn', 'Sb', 'Te', 'La', 'Ce', 'Nd', 'Gd', 'O', 'N', 'F', 'Cl']
        
        for i in range(n_candidates):
            # Generate random composition
            n_elements = np.random.randint(2, 5)  # 2-4 elements
            selected_elements = np.random.choice(elements, n_elements, replace=False)
            
            # Generate stoichiometry
            stoich = np.random.randint(1, 10, n_elements)
            
            # Create formula
            formula_parts = [f"{elem}{stoich[j]}" if stoich[j] > 1 else elem 
                           for j, elem in enumerate(selected_elements)]
            formula = "".join(formula_parts)
            
            candidates.append(formula)
        
        print(f"✓ Generated {len(candidates)} candidate compositions")
        return candidates
    
    def substitute_elements(self, base_composition: str, 
                          n_variants: int = 100) -> List[str]:
        """
        Generate variants by element substitution
        
        Args:
            base_composition: Starting composition (e.g., "LiFePO4")
            n_variants: Number of variants to generate
        
        Returns:
            List of variant compositions
        """
        print(f"\nGenerating {n_variants} variants of {base_composition}...")
        
        # Element substitution rules (simplified)
        substitutions = {
            'Li': ['Na', 'K'],
            'Na': ['Li', 'K'],
            'Fe': ['Co', 'Ni', 'Mn'],
            'Co': ['Fe', 'Ni', 'Mn'],
            'Ni': ['Fe', 'Co', 'Mn'],
            'P': ['As', 'Sb'],
            'O': ['S', 'Se']
        }
        
        variants = [base_composition]  # Include original
        
        # Generate variants (simplified)
        for i in range(n_variants - 1):
            variant = base_composition  # Placeholder - implement actual substitution
            variants.append(variant)
        
        print(f"✓ Generated {len(variants)} variants")
        return variants


# ============================================================================
# ATOMISTIC SIMULATIONS
# ============================================================================

class SimulationEngine:
    """
    Run atomistic simulations (DFT, MD, Monte Carlo)
    CPU-bound but highly parallelizable
    """
    
    def __init__(self, n_workers: int = None):
        self.n_workers = n_workers or max(1, mp.cpu_count() - 2)
        self.ase_available = ASE_AVAILABLE
    
    def run_structure_optimization(self, material: Material) -> Dict:
        """
        Optimize crystal structure using force field or DFT
        
        Args:
            material: Material to optimize
        
        Returns:
            Optimized structure and energy
        """
        if not self.ase_available or not material.structure:
            return {'status': 'error', 'message': 'ASE not available or no structure'}
        
        print(f"\n[CPU] Optimizing structure: {material.composition}")
        
        # Convert to ASE Atoms (simplified)
        # In production, proper conversion from Pymatgen to ASE
        atoms = Atoms('H2', positions=[[0, 0, 0], [0, 0, 0.74]])  # Placeholder
        
        # Set calculator (using Lennard-Jones as example - use DFT in production)
        atoms.calc = LennardJones()
        
        # Optimize
        opt = BFGS(atoms)
        opt.run(fmax=0.05)
        
        final_energy = atoms.get_potential_energy()
        
        return {
            'status': 'completed',
            'final_energy': final_energy,
            'optimized_structure': atoms
        }
    
    def calculate_band_structure(self, material: Material) -> Dict:
        """Calculate electronic band structure"""
        # Placeholder - in production, interface with VASP/Quantum ESPRESSO
        return {
            'band_gap': np.random.uniform(0, 5),
            'is_direct': np.random.choice([True, False]),
            'vbm': -2.5,
            'cbm': 0.5
        }
    
    def run_molecular_dynamics(self, material: Material, 
                              temperature: float = 300,
                              steps: int = 10000) -> Dict:
        """
        Run molecular dynamics simulation
        
        Args:
            material: Material structure
            temperature: Temperature in K
            steps: Number of MD steps
        
        Returns:
            MD trajectory and properties
        """
        print(f"\n[CPU] Running MD simulation at {temperature}K for {steps} steps...")
        
        # Placeholder - in production, use ASE MD or LAMMPS
        results = {
            'status': 'completed',
            'temperature': temperature,
            'steps': steps,
            'avg_energy': -50.0 + np.random.randn(),
            'diffusion_coefficient': np.random.uniform(1e-10, 1e-8)
        }
        
        print(f"✓ MD simulation complete")
        return results
    
    def parallel_simulations(self, materials: List[Material],
                           simulation_type: str = 'optimization') -> List[Dict]:
        """
        Run simulations in parallel across multiple materials
        
        Args:
            materials: List of materials
            simulation_type: 'optimization', 'band_structure', 'md'
        
        Returns:
            List of simulation results
        """
        print(f"\n[CPU] Running {simulation_type} simulations on {len(materials)} materials...")
        print(f"  Using {self.n_workers} parallel workers")
        
        if simulation_type == 'optimization':
            func = self.run_structure_optimization
        elif simulation_type == 'band_structure':
            func = self.calculate_band_structure
        elif simulation_type == 'md':
            func = self.run_molecular_dynamics
        else:
            raise ValueError(f"Unknown simulation type: {simulation_type}")
        
        results = Parallel(n_jobs=self.n_workers)(
            delayed(func)(material) for material in materials
        )
        
        print(f"✓ Completed {len(results)} simulations")
        return results


# ============================================================================
# SYNTHESIS PLANNING
# ============================================================================

class SynthesisPlanner:
    """
    Predict synthesizability and suggest synthesis routes
    """
    
    def __init__(self):
        self.known_phases = self._load_known_phases()
    
    def _load_known_phases(self) -> set:
        """Load database of known synthesizable phases"""
        # In production, load from Materials Project or ICSD
        return set()
    
    def predict_synthesizability(self, material: Material) -> float:
        """
        Predict likelihood of successful synthesis (0-1)
        
        Considers:
        - Formation energy
        - Phase stability
        - Element compatibility
        - Known similar phases
        """
        score = 0.5  # Base score
        
        # Check if similar composition exists
        if material.composition in self.known_phases:
            score += 0.3
        
        # Formation energy check
        if material.formation_energy is not None:
            if material.formation_energy < -1.0:
                score += 0.2
            elif material.formation_energy > 0.5:
                score -= 0.3
        
        return np.clip(score, 0, 1)
    
    def suggest_synthesis_route(self, material: Material) -> Dict:
        """
        Suggest experimental synthesis procedure
        
        Returns:
            Synthesis route with precursors, temperature, atmosphere
        """
        routes = []
        
        # Solid-state route
        routes.append({
            'method': 'Solid-state reaction',
            'precursors': self._get_precursors(material.composition),
            'temperature': '800-1200°C',
            'atmosphere': 'Air or Ar',
            'time': '12-48 hours',
            'grinding_cycles': 2
        })
        
        # Solution route (if applicable)
        if self._is_solution_compatible(material):
            routes.append({
                'method': 'Sol-gel synthesis',
                'precursors': self._get_solution_precursors(material.composition),
                'temperature': '400-800°C',
                'atmosphere': 'Air',
                'time': '4-12 hours'
            })
        
        return {
            'recommended_routes': routes,
            'difficulty': self._assess_difficulty(material)
        }
    
    def _get_precursors(self, composition: str) -> List[str]:
        """Get solid-state precursors"""
        # Simplified - in production, use chemical knowledge base
        return ['Carbonate', 'Oxide', 'Hydroxide']
    
    def _is_solution_compatible(self, material: Material) -> bool:
        """Check if solution synthesis is viable"""
        return True  # Simplified
    
    def _get_solution_precursors(self, composition: str) -> List[str]:
        """Get solution-phase precursors"""
        return ['Nitrate', 'Acetate', 'Citrate']
    
    def _assess_difficulty(self, material: Material) -> str:
        """Assess synthesis difficulty"""
        if material.formation_energy and material.formation_energy < -2.0:
            return 'Easy'
        elif material.formation_energy and material.formation_energy > 0:
            return 'Challenging'
        return 'Moderate'


# ============================================================================
# MAIN PIPELINE
# ============================================================================

class MaterialsDiscoveryPipeline:
    """
    Complete materials discovery pipeline
    Integrates generation, prediction, simulation, and synthesis planning
    """
    
    def __init__(self, use_gpu: bool = True, n_workers: int = None):
        self.property_predictor = PropertyPredictionEngine(use_gpu=use_gpu)
        self.generator = MaterialsGenerator(use_gpu=use_gpu)
        self.simulator = SimulationEngine(n_workers=n_workers)
        self.synthesis_planner = SynthesisPlanner()
        
        self.materials_library = []
        self.predictions = {}
        self.simulation_results = {}
        
        print("\n" + "="*70)
        print("MATERIALS DISCOVERY PIPELINE INITIALIZED")
        print("="*70)
        print(f"GPU Acceleration: {use_gpu and torch.cuda.is_available() if PYTORCH_AVAILABLE else False}")
        print(f"CPU Workers: {n_workers or mp.cpu_count()-2}")
        print("="*70)
    
    def discover_materials(self, 
                          target_properties: Dict[str, float],
                          n_candidates: int = 10000,
                          screen_top_n: int = 100) -> pd.DataFrame:
        """
        Complete discovery workflow
        
        Args:
            target_properties: Desired properties
            n_candidates: Number of candidates to generate
            screen_top_n: Top N to simulate
        
        Returns:
            DataFrame of discovered materials ranked by promise
        """
        print("\n" + "="*70)
        print("MATERIALS DISCOVERY WORKFLOW")
        print("="*70)
        
        # Step 1: Generate candidates
        print("\n[1/5] Generating candidate materials...")
        compositions = self.generator.generate_compositions(
            target_properties=target_properties,
            n_candidates=n_candidates
        )
        
        materials = [Material(composition=comp, material_id=f"MAT_{i:06d}") 
                    for i, comp in enumerate(compositions)]
        
        # Step 2: Predict properties (GPU-accelerated)
        print("\n[2/5] Predicting properties...")
        predictions = self.property_predictor.batch_predict(materials)
        
        # Step 3: Filter and rank
        print("\n[3/5] Filtering and ranking...")
        ranked = self._rank_by_targets(materials, predictions, target_properties)
        top_materials = ranked[:screen_top_n]
        
        # Step 4: Run simulations (CPU-parallel)
        print("\n[4/5] Running atomistic simulations...")
        sim_results = self.simulator.parallel_simulations(
            top_materials,
            simulation_type='optimization'
        )
        
        # Step 5: Synthesis planning
        print("\n[5/5] Planning synthesis routes...")
        synthesis_plans = [self.synthesis_planner.suggest_synthesis_route(m) 
                          for m in top_materials]
        
        # Compile results
        results = self._compile_results(
            top_materials, 
            predictions[:screen_top_n],
            sim_results,
            synthesis_plans
        )
        
        print("\n" + "="*70)
        print("DISCOVERY COMPLETE")
        print("="*70)
        print(f"Candidates generated: {n_candidates}")
        print(f"Top candidates simulated: {screen_top_n}")
        print(f"Promising materials: {len(results)}")
        
        return results
    
    def _rank_by_targets(self, materials, predictions, targets):
        """Rank materials by how well they match target properties"""
        scores = []
        
        for material, pred in zip(materials, predictions):
            score = 0
            for prop, target_val in targets.items():
                if hasattr(pred, prop):
                    pred_val = getattr(pred, prop)
                    if pred_val is not None:
                        # Normalized distance
                        error = abs(pred_val - target_val) / (abs(target_val) + 1e-6)
                        score += 1.0 / (1.0 + error)
            
            scores.append((score, material))
        
        # Sort by score descending
        scores.sort(reverse=True, key=lambda x: x[0])
        return [mat for _, mat in scores]
    
    def _compile_results(self, materials, predictions, sim_results, synthesis_plans):
        """Compile all results into DataFrame"""
        data = []
        
        for i, (mat, pred, sim, synth) in enumerate(zip(materials, predictions, sim_results, synthesis_plans)):
            row = {
                'material_id': mat.material_id,
                'composition': mat.composition,
                'formation_energy': sim.get('final_energy'),
                'band_gap': pred.band_gap,
                'bulk_modulus': pred.bulk_modulus,
                'synthesizability': self.synthesis_planner.predict_synthesizability(mat),
                'synthesis_method': synth['recommended_routes'][0]['method'] if synth['recommended_routes'] else 'Unknown',
                'synthesis_difficulty': synth['difficulty']
            }
            data.append(row)
        
        df = pd.DataFrame(data)
        df = df.sort_values('synthesizability', ascending=False)
        
        return df
    
    def save_results(self, results: pd.DataFrame, filename: str = 'discovered_materials.csv'):
        """Save results to CSV"""
        results.to_csv(filename, index=False)
        print(f"\n✓ Results saved to {filename}")
    
    def export_structures(self, materials: List[Material], output_dir: str = 'structures'):
        """Export crystal structures to CIF files"""
        os.makedirs(output_dir, exist_ok=True)
        
        for material in materials:
            if material.structure and PYMATGEN_AVAILABLE:
                cif_file = os.path.join(output_dir, f"{material.material_id}.cif")
                writer = CifWriter(material.structure)
                writer.write_file(cif_file)
        
        print(f"✓ Structures exported to {output_dir}/")


# ============================================================================
# SPECIALIZED APPLICATIONS
# ============================================================================

class BatteryMaterialsDesigner(MaterialsDiscoveryPipeline):
    """Specialized pipeline for battery materials"""
    
    def discover_cathode_materials(self, 
                                  target_voltage: float = 3.5,
                                  target_capacity: float = 150) -> pd.DataFrame:
        """Discover novel cathode materials"""
        
        print("\nBATTERY CATHODE MATERIALS DISCOVERY")
        print(f"Target voltage: {target_voltage} V")
        print(f"Target capacity: {target_capacity} mAh/g")
        
        # Generate Li-containing compositions
        elements = ['Li', 'Fe', 'Mn', 'Co', 'Ni', 'P', 'O', 'S']
        
        compositions = self.generator.generate_compositions(
            target_properties={'voltage': target_voltage, 'capacity': target_capacity},
            n_candidates=5000,
            elements=elements
        )
        
        # Filter for Li-containing only
        compositions = [c for c in compositions if 'Li' in c]
        
        materials = [Material(composition=comp, material_id=f"CATH_{i:06d}") 
                    for i, comp in enumerate(compositions)]
        
        return self.discover_materials(
            target_properties={'voltage': target_voltage, 'capacity': target_capacity},
            n_candidates=len(materials),
            screen_top_n=50
        )


class PhotovoltaicMaterialsDesigner(MaterialsDiscoveryPipeline):
    """Specialized pipeline for solar cell materials"""
    
    def discover_absorber_materials(self,
                                   target_band_gap: float = 1.34) -> pd.DataFrame:
        """Discover novel solar absorber materials"""
        
        print("\nSOLAR ABSORBER MATERIALS DISCOVERY")
        print(f"Target band gap: {target_band_gap} eV (Shockley-Queisser optimum)")
        
        # Perovskite-like or chalcogenide compositions
        elements = ['Cs', 'Rb', 'K', 'Pb', 'Sn', 'Ge', 'I', 'Br', 'Cl',
                   'Cu', 'Zn', 'Sn', 'S', 'Se', 'Te']
        
        return self.discover_materials(
            target_properties={'band_gap': target_band_gap},
            n_candidates=5000,
            screen_top_n=100
        )


class StructuralMaterialsDesigner(MaterialsDiscoveryPipeline):
    """Specialized pipeline for high-strength structural materials"""
    
    def discover_alloys(self,
                       target_strength: float = 1000,
                       target_density: float = 5.0) -> pd.DataFrame:
        """Discover novel high-strength alloys"""
        
        print("\nHIGH-STRENGTH ALLOY DISCOVERY")
        print(f"Target strength: {target_strength} MPa")
        print(f"Target density: {target_density} g/cm³")
        
        # Common alloying elements
        elements = ['Al', 'Ti', 'V', 'Cr', 'Fe', 'Co', 'Ni', 'Cu', 
                   'Zr', 'Nb', 'Mo', 'W']
        
        return self.discover_materials(
            target_properties={
                'youngs_modulus': target_strength, 
                'density': target_density
            },
            n_candidates=3000,
            screen_top_n=50
        )


# ============================================================================
# QUANTUM MATERIALS (OPTIONAL)
# ============================================================================

class QuantumMaterialsSimulator:
    """Quantum computing simulations for materials (experimental)"""
    
    def __init__(self):
        self.qiskit_available = QISKIT_AVAILABLE
    
    def simulate_electronic_structure(self, material: Material) -> Dict:
        """
        Simulate electronic structure using quantum computer
        (Placeholder - requires extensive implementation)
        """
        if not self.qiskit_available:
            return {'error': 'Qiskit not available'}
        
        print("\n[QUANTUM] Simulating electronic structure...")
        
        # Create simple quantum circuit (demonstration)
        qc = QuantumCircuit(4, 4)
        qc.h(0)
        qc.cx(0, 1)
        qc.measure_all()
        
        # Simulate
        backend = Aer.get_backend('qasm_simulator')
        result = execute(qc, backend, shots=1000).result()
        counts = result.get_counts()
        
        return {
            'quantum_simulation': 'completed',
            'qubit_counts': counts
        }


# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """Demonstrate materials discovery pipeline"""
    
    print("="*70)
    print("MATERIALS SCIENCE DISCOVERY PIPELINE")
    print("="*70)
    print("\nCapabilities:")
    print("  ✓ High-throughput materials generation")
    print("  ✓ GPU-accelerated property prediction")
    print("  ✓ Parallel atomistic simulations")
    print("  ✓ Synthesis route planning")
    print("  ✓ Multi-scale representation learning")
    print("  ✓ Inverse materials design")
    print("="*70)
    
    # Initialize pipeline
    pipeline = MaterialsDiscoveryPipeline(use_gpu=True, n_workers=8)
    
    # Example 1: Discover battery materials
    print("\n\nEXAMPLE 1: BATTERY CATHODE DISCOVERY")
    print("-" * 70)
    battery_designer = BatteryMaterialsDesigner(use_gpu=True)
    cathodes = battery_designer.discover_cathode_materials(
        target_voltage=3.8,
        target_capacity=180
    )
    print("\nTop 5 cathode materials:")
    print(cathodes.head())
    
    # Example 2: Discover solar materials
    print("\n\nEXAMPLE 2: SOLAR ABSORBER DISCOVERY")
    print("-" * 70)
    solar_designer = PhotovoltaicMaterialsDesigner(use_gpu=True)
    absorbers = solar_designer.discover_absorber_materials(target_band_gap=1.34)
    print("\nTop 5 solar absorbers:")
    print(absorbers.head())
    
    # Example 3: Structural materials
    print("\n\nEXAMPLE 3: HIGH-STRENGTH ALLOY DISCOVERY")
    print("-" * 70)
    structural_designer = StructuralMaterialsDesigner(use_gpu=True)
    alloys = structural_designer.discover_alloys(
        target_strength=1200,
        target_density=4.5
    )
    print("\nTop 5 alloys:")
    print(alloys.head())
    
    print("\n" + "="*70)
    print("SETUP INSTRUCTIONS")
    print("="*70)
    print("\nCore packages:")
    print("  pip install pymatgen ase torch pandas numpy")
    print("\nOptional:")
    print("  pip install dask distributed  # Distributed computing")
    print("  pip install qiskit  # Quantum simulations")
    print("\nFor GPU:")
    print("  pip install torch --index-url https://download.pytorch.org/whl/cu118")
    print("\n" + "="*70)


if __name__ == "__main__":
    main()